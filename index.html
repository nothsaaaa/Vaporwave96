<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" /><title>Raytracer</title>
<style>body,html{margin:0;overflow:hidden;background:#222;display:flex;justify-content:center;align-items:center;height:100vh;user-select:none}canvas{image-rendering:pixelated;width:512px;height:512px;background:#000;cursor:crosshair}</style>
</head><body>
<canvas id="c" width=128 height=128></canvas>
<script>
(() => {
const R=128,D=1e3,F0=100,F1=D,c=document.getElementById('c'),ctx=c.getContext('2d'),img=ctx.createImageData(R,R),px=img.data;
const v3=(x,y,z)=>({x,y,z}),add=(a,b)=>v3(a.x+b.x,a.y+b.y,a.z+b.z),sub=(a,b)=>v3(a.x-b.x,a.y-b.y,a.z-b.z),mul=(a,s)=>v3(a.x*s,a.y*s,a.z*s);
const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z,len=a=>Math.sqrt(dot(a,a)),norm=a=>{let l=len(a);return l?mul(a,1/l):a};
const cross=(a,b)=>v3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x),clamp=(x,m,M)=>x<m?m:x>M?M:x,lerp=(a,b,t)=>a+(b-a)*t;

function rotateVec(v,r){
  let cx=Math.cos(r.x),sx=Math.sin(r.x),
      cy=Math.cos(r.y),sy=Math.sin(r.y),
      cz=Math.cos(r.z),sz=Math.sin(r.z);
  let x1=v.x,y1=v.y*cx - v.z*sx,z1=v.y*sx + v.z*cx;
  let x2=x1*cy + z1*sy, y2=y1, z2=-x1*sy + z1*cy;
  let x3=x2*cz - y2*sz, y3=x2*sz + y2*cz, z3=z2;
  return v3(x3,y3,z3);
}

function invRotateVec(v,r){
  let cx=Math.cos(-r.x),sx=Math.sin(-r.x),
      cy=Math.cos(-r.y),sy=Math.sin(-r.y),
      cz=Math.cos(-r.z),sz=Math.sin(-r.z);
  let x1=v.x*cz - v.y*sz, y1=v.x*sz + v.y*cz, z1=v.z;
  let x2=x1*cy + z1*sy, y2=y1, z2=-x1*sy + z1*cy;
  let x3=x2, y3=y2*cx - z2*sx, z3=y2*sx + z2*cx;
  return v3(x3,y3,z3);
}

const scene=[], idGen=(function(){let i=1;return ()=>i++;})();

function create(x,y,z,s,type,rot={x:0,y:0,z:0}){
  const id=idGen();
  scene.push({id,pos:v3(x,y,z),s,type,rot});
  return id;
}

function ChangeObjectProperties(id,rot=null,pos=null){
  const o=scene.find(o=>o.id===id);
  if(!o)return;
  if(rot)o.rot=Object.assign(o.rot||{},rot);
  if(pos)o.pos=pos;
}

function intersectSphere(o,ro,rd){
  let oc=sub(ro,o.pos),a=dot(rd,rd),b=2*dot(oc,rd),c=dot(oc,oc)-o.s*o.s,d=b*b-4*a*c;
  if(d<0)return null;
  d=Math.sqrt(d);
  let t1=(-b-d)/(2*a),t2=(-b+d)/(2*a);
  if(t1>t2)[t1,t2]=[t2,t1];
  if(t1<0)t1=t2;if(t1<0)return null;
  return t1;
}

function intersectCube(o,ro,rd){
  let roLocal = sub(ro,o.pos);
  roLocal = invRotateVec(roLocal,o.rot);
  let rdLocal = invRotateVec(rd,o.rot);

  let tMin=-Infinity,tMax=Infinity;
  for(let i=0;i<3;i++){
    let roC=roLocal[['x','y','z'][i]], rdC=rdLocal[['x','y','z'][i]];
    let minB=-o.s, maxB=o.s;
    if(Math.abs(rdC)<1e-6){
      if(roC<minB||roC>maxB)return null;
    } else {
      let t1=(minB-roC)/rdC, t2=(maxB-roC)/rdC;
      if(t1>t2)[t1,t2]=[t2,t1];
      if(t1>tMin)tMin=t1;
      if(t2<tMax)tMax=t2;
      if(tMin>tMax)return null;
      if(tMax<0)return null;
    }
  }
  return tMin>0?tMin:tMax>0?tMax:null;
}

function intersectPlane(o,ro,rd){
  if(Math.abs(rd.y)<1e-6)return null;
  let t=(o.pos.y - ro.y)/rd.y;
  return t>0?t:null;
}

function intersect(o,ro,rd){
  if(o.type==='sphere')return intersectSphere(o,ro,rd);
  if(o.type==='plane')return intersectPlane(o,ro,rd);
  if(o.type==='cube')return intersectCube(o,ro,rd);
  return null;
}

function sceneIntersect(ro,rd){
  let tmin=Infinity,hit=null;
  for(let o of scene){
    let t=intersect(o,ro,rd);
    if(t!==null && t<tmin){tmin=t;hit=o;}
  }
  return hit?{t:tmin,obj:hit}:null;
}

function fogColor(){return {r:180,g:180,b:180};}

function sphereNormalMap(p,n){
  const t=Math.acos(clamp(n.y,-1,1)),f=Math.atan2(n.z,n.x),bs=0.3,freq=10;
  const dx=Math.sin(freq*t)*Math.cos(freq*f),dy=Math.cos(freq*t)*Math.sin(freq*f),dz=Math.sin(freq*t)*Math.sin(freq*f);
  return norm(add(n,mul(v3(dx,dy,dz),bs)));
}

function planeNormalMap(p,n){
  const size=20,cx=Math.floor(p.x/size),cz=Math.floor(p.z/size),check=((cx+cz)%2===0?1:-1),bs=0.5;
  return norm(add(n,v3(0,bs*check,0)));
}

function cubeNormalMap(p,n,o){
  let pLocal=invRotateVec(sub(p,o.pos),o.rot);
  let absX=Math.abs(pLocal.x), absY=Math.abs(pLocal.y), absZ=Math.abs(pLocal.z);
  let maxC=Math.max(absX,absY,absZ);
  let nLocal=v3(0,0,0);
  if(maxC===absX)nLocal.x=pLocal.x>0?1:-1;
  else if(maxC===absY)nLocal.y=pLocal.y>0?1:-1;
  else nLocal.z=pLocal.z>0?1:-1;

  const freq=10, bs=0.3;
  let u,v;
  if(nLocal.x!==0){u=pLocal.z;v=pLocal.y;}
  else if(nLocal.y!==0){u=pLocal.x;v=pLocal.z;}
  else {u=pLocal.x;v=pLocal.y;}
  let dx=Math.sin(freq*u)*Math.cos(freq*v);
  let dy=Math.cos(freq*u)*Math.sin(freq*v);
  let dz=Math.sin(freq*u)*Math.sin(freq*v);
  let mapped=add(nLocal,mul(v3(dx,dy,dz),bs));
  mapped=norm(mapped);

  return norm(rotateVec(mapped,o.rot));
}

function inShadow(p,ld){
  const e=1e-2,o=add(p,mul(ld,e));
  for(let o2 of scene){
    let t=intersect(o2,o,ld);
    if(t!==null && t<1e4)return true;
  }
  return false;
}

function shade(p,n,d,ld,mat,o=null){
  let NdotL=Math.max(0,dot(n,ld)),base={r:180,g:180,b:180};
  if(mat==='plane'){
    const sz=50,cx=Math.floor(p.x/sz),cz=Math.floor(p.z/sz);
    const c=((cx+cz)%2===0?200:100);
    base={r:c,g:c,b:c};
  } else if(mat==='sphere'){
    let c=clamp(200*NdotL+50,0,255);
    base={r:c,g:50,b:50};
  } else if(mat==='cube'){
    let c=clamp(150+100*NdotL,0,255);
    base={r:50,g:c,b:50};
  }
  let sh=inShadow(p,ld)?0.3:1;
  base.r*=sh;base.g*=sh;base.b*=sh;
  let fog=clamp((d-F0)/(F1-F0),0,1),f=fogColor();
  return {r:lerp(base.r,f.r,fog),g:lerp(base.g,f.g,fog),b:lerp(base.b,f.b,fog)};
}

let cam=v3(0,0,-500), rot={yaw:0,pitch:0};
function getFwd(){return norm({x:Math.cos(rot.pitch)*Math.sin(rot.yaw),y:Math.sin(rot.pitch),z:Math.cos(rot.pitch)*Math.cos(rot.yaw)});}
function getRight(){return norm(cross(getFwd(),v3(0,1,0)));}
function getUp(){return norm(cross(getRight(),getFwd()));}
function getRay(x,y){
  const px=((x+0.5)/R)*2-1,py=1-((y+0.5)/R)*2,scale=Math.tan(Math.PI/6);
  const f=getFwd(),r=getRight(),u=getUp();
  return norm(add(add(mul(f,1),mul(r,px*scale)),mul(u,py*scale)));
}

const keys={};window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
let mouseDown=false;c.addEventListener('mousedown',e=>{mouseDown=true;c.requestPointerLock();});
document.addEventListener('mouseup',e=>{mouseDown=false;document.exitPointerLock();});
document.addEventListener('pointerlockchange',()=>{if(document.pointerLockElement!==c)mouseDown=false;});
document.addEventListener('mousemove',e=>{
  if(!mouseDown)return;
  const s=0.002;
  rot.yaw-=e.movementX*s;
  rot.pitch-=e.movementY*s;
  rot.pitch=clamp(rot.pitch,-Math.PI/2+0.01,Math.PI/2-0.01);
});

function update(dt){
  const sp=400;
  const f=getFwd(),r=getRight();
  if(keys['w'])cam=add(cam,mul(f,sp*dt));
  if(keys['s'])cam=sub(cam,mul(f,sp*dt));
  if(keys['a'])cam=sub(cam,mul(r,sp*dt));
  if(keys['d'])cam=add(cam,mul(r,sp*dt));
  if(keys[' '])cam=add(cam,v3(0,1,0));
  if(keys['shift'])cam=sub(cam,v3(0,1,0));
}

const sunDir=norm({x:Math.cos(Math.PI/4)*Math.sin(Math.PI*0.75),y:Math.sin(Math.PI/4),z:Math.cos(Math.PI/4)*Math.cos(Math.PI*0.75)});
const MAX_FPS=24,FRAME_D=1000/MAX_FPS;
let last=0;

function render(now=performance.now()){
  if(!last)last=now;
  const elapsed=now-last;if(elapsed<FRAME_D){requestAnimationFrame(render);return;}
  last=now;update(elapsed/1000);
  let hits=0;
  for(let y=0;y<R;y++)for(let x=0;x<R;x++){
    let i=(y*R+x)*4;
    let rd=getRay(x,y),ro=cam;
    let hit=sceneIntersect(ro,rd);
    if(!hit || hit.t>D){
      let f=fogColor();
      px[i]=f.r;px[i+1]=f.g;px[i+2]=f.b;px[i+3]=255;continue;
    }
    hits++;
    let p=add(ro,mul(rd,hit.t));
    let n;
    if(hit.obj.type==='sphere')n=sphereNormalMap(p,norm(sub(p,hit.obj.pos)));
    else if(hit.obj.type==='plane')n=planeNormalMap(p,v3(0,1,0));
    else if(hit.obj.type==='cube')n=cubeNormalMap(p,norm(sub(p,hit.obj.pos)),hit.obj);
    let c=shade(p,n,hit.t,sunDir,hit.obj.type,hit.obj);
    px[i]=c.r;px[i+1]=c.g;px[i+2]=c.b;px[i+3]=255;
  }
  ctx.putImageData(img,0,0);
  setTimeout(() => requestAnimationFrame(render),Math.min(hits,18));
}
render();

let sphereID = create(0,0,0,100,'sphere');
let planeID = create(0,-100,0,0,'plane');
let cubeID = create(200,0,0,50,'cube',{x:0,y:0,z:0});

let angle=0;
setInterval(() => {
  angle+=0.01;
  ChangeObjectProperties(cubeID,{x:0,y:angle,z:angle});
},16);

})();
</script>
</body></html>
